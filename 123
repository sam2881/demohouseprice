def flatten_json(df, prefix=""):
    """
    Flattens a DataFrame with complex nested fields (Arrays and Structs) by converting them into individual columns
    and allows for dynamic aliasing in the select statement.

    Parameters:
    - df: The input DataFrame with complex nested fields
    - prefix: A string prefix to prepend to column aliases for uniqueness and traceability
    
    Returns:
    - A tuple of the flattened DataFrame and the select expression list.
    """
    select_expressions = []  # To store final select expressions
    complex_fields = [(field.name, field.dataType) for field in df.schema.fields
                      if isinstance(field.dataType, (ArrayType, StructType))]

    processed_columns = set()  # To track processed columns and avoid duplicates

    while complex_fields:
        new_complex_fields = []
        for col_name, data_type in complex_fields:
            full_col_name = f"{prefix}.{col_name}" if prefix else col_name
            full_col_name = full_col_name.strip('.')

            if isinstance(data_type, StructType):
                for field in data_type.fields:
                    new_col_name = f"{full_col_name}.{field.name}"
                    if isinstance(field.dataType, (ArrayType, StructType)):
                        new_complex_fields.append((new_col_name, field.dataType))
                    else:
                        if new_col_name not in processed_columns:
                            alias_name = new_col_name.replace('.', '_')
                            select_expressions.append(f"col('{new_col_name}').alias('{alias_name}')")
                            processed_columns.add(new_col_name)

            elif isinstance(data_type, ArrayType):
                exploded_col_name = f"{full_col_name}_exploded"
                df = df.withColumn(exploded_col_name, explode_outer(col(full_col_name)))
                if isinstance(data_type.elementType, (ArrayType, StructType)):
                    new_complex_fields.append((exploded_col_name, data_type.elementType))
                else:
                    if exploded_col_name not in processed_columns:
                        select_expressions.append(f"col('{exploded_col_name}').alias('{exploded_col_name}')")
                        processed_columns.add(exploded_col_name)

        complex_fields = new_complex_fields

    select_clause = ",\n    ".join(select_expressions)
    select_statement = f"df.select(\n    {select_clause}\n).show(truncate=False)"
    print(select_statement)  # This prints the select statement
    
    return df, select_expressions
