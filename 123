def flatten_json(df):
    """
    Flattens a DataFrame with complex nested fields (Arrays and Structs) by converting them into individual columns
    and builds a customizable select statement.
    
    Parameters:
    - df: The input DataFrame with complex nested fields.
    
    Returns:
    - The flattened DataFrame with all complex fields expanded into separate columns.
    - Prints the select statement for further customization.
    """
    select_expressions = []  # List to hold select expressions for final DataFrame viewing
    process_queue = [(field.name, field.dataType) for field in df.schema.fields
                     if isinstance(field.dataType, (ArrayType, StructType))]

    while process_queue:
        col_name, data_type = process_queue.pop(0)
        print("Processing: " + col_name + " Type: " + str(type(data_type)))

        if isinstance(data_type, StructType):
            for field in data_type.fields:
                new_col_name = f"{col_name}_{field.name}"
                df = df.withColumn(new_col_name, col(f"{col_name}.{field.name}"))
                select_expressions.append(new_col_name)
                if isinstance(field.dataType, (ArrayType, StructType)):
                    process_queue.append((new_col_name, field.dataType))

        elif isinstance(data_type, ArrayType):
            exploded_col_name = f"{col_name}_exploded"
            df = df.withColumn(exploded_col_name, explode_outer(col(col_name)))
            select_expressions.append(exploded_col_name)
            if isinstance(data_type.elementType, StructType):
                for subfield in data_type.elementType.fields:
                    new_col_name = f"{exploded_col_name}_{subfield.name}"
                    df = df.withColumn(new_col_name, col(f"{exploded_col_name}.{subfield.name}"))
                    select_expressions.append(new_col_name)
                    if isinstance(subfield.dataType, (ArrayType, StructType)):
                        process_queue.append((new_col_name, subfield.dataType))

    # Build and print the select statement for manual editing if necessary
    select_clause = ",\n    ".join(f"col('{expr}').alias('{expr}')" for expr in select_expressions)
    select_statement = f"df.select(\n    {select_clause}\n).show(truncate=False)"
    print(select_statement)

    return df, select_statement  # Return the DataFrame and the select statement

# Example of usage, assuming 'spark' is a SparkSession and 'df' is your DataFrame:
df, select_statement = flatten_json(df)
exec(select_statement)  # Execute the select statement to view the DataFrame
