from pyspark.sql.functions import col, explode_outer

def flatten_json(df, prefix=""):
    """
    Flattens a DataFrame with complex nested fields (Arrays and Structs) by converting them into individual columns
    and allows for dynamic aliasing in the select statement.
    
    Parameters:
    - df: The input DataFrame with complex nested fields
    - prefix: A string prefix to prepend to column aliases for uniqueness and traceability
    
    Returns:
    - A tuple of the flattened DataFrame and the select expression list.
    """
    select_expressions = []  # To store select expressions for final selection
    complex_fields = [(field.name, field.dataType) for field in df.schema.fields
                      if isinstance(field.dataType, (ArrayType, StructType))]
    
    while complex_fields:
        new_complex_fields = []
        for col_name, data_type in complex_fields:
            full_col_name = f"{prefix}{col_name}" if prefix else col_name
            
            if isinstance(data_type, StructType):
                # Handle StructType by expanding its subfields
                for field in data_type.fields:
                    new_col_name = f"{full_col_name}_{field.name}"
                    df = df.withColumn(new_col_name, col(f"{col_name}.{field.name}"))
                    select_expressions.append(f"col('{new_col_name}').alias('{new_col_name}')")
                    if isinstance(field.dataType, (ArrayType, StructType)):
                        new_complex_fields.append((new_col_name, field.dataType))
            elif isinstance(data_type, ArrayType):
                # Handle ArrayType by exploding the array
                exploded_col_name = f"{full_col_name}_exploded"
                df = df.withColumn(exploded_col_name, explode_outer(col(col_name)))
                select_expressions.append(f"col('{exploded_col_name}').alias('{exploded_col_name}')")
                if isinstance(data_type.elementType, (ArrayType, StructType)):
                    new_complex_fields.append((exploded_col_name, data_type.elementType))

        complex_fields = new_complex_fields
    
    # Generate the select statement
    select_statement = f"df.select(\n    {',\n    '.join(select_expressions)}\n).show(truncate=False)"
    print(select_statement)  # Print or return this statement as needed
    
    return df, select_expressions

# Usage Example
df_flattened, select_expr = flatten_json(df)
df_flattened.show()
